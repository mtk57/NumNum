<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple Number Connect</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SimpleNumConnect">
    <link rel="apple-touch-icon" href="icons/icon-180x180.png">
    <style>
        /* --- 全体レイアウト --- */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #fff0f5; /* ラベンダーブラッシュ (薄いピンク) */
            color: #6d4c41; /* ブラウン系 */
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* ホワイト */
            box-shadow: 0 10px 20px rgba(211, 175, 189, 0.25); /* ピンク系の影 */
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            box-sizing: border-box;
            position: relative;
        }

        /* --- ゲーム盤のレイアウト --- */
        #game-board {
            position: relative;
            width: 100%;
            max-width: 370px;
            aspect-ratio: 1 / 1;
            margin: 0 auto 15px auto;
        }

        #glow-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        #grid-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #grid-container {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 8px;
            z-index: 2;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        /* --- セルとエフェクト --- */
        .cell {
            background-color: #ffe4e1; /* ミスティーローズ */
            color: #a1887f; /* ブラウンがかったグレー */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease, opacity 0.3s ease;
            position: relative;
            aspect-ratio: 1 / 1;
            width: 88%;
            height: 88%;
            justify-self: center;
            align-self: center;
        }

        .cell.selected {
            background-color: #ff80ab; /* 明るいピンク */
            color: #ffffff; /* ホワイト */
            transform: scale(1.15);
        }

        .glow-node {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 15px #ff80ab, 0 0 25px #ff80ab;
            transition: opacity 0.2s;
        }

        #line-canvas {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            pointer-events: none;
            z-index: 1; 
        }

        /* --- クリア時のアニメーション --- */
        .cell.clearing {
            animation: cellClearEffect 0.6s forwards ease-out;
        }
        @keyframes cellClearEffect {
            0% { opacity: 1; transform: scale(1.1) rotate(0deg); background-color: #ffd180; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 0.7; }
            100% { opacity: 0; transform: scale(0.3) rotate(360deg); background-color: #ffd180; }
        }
        .cell.falling {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .cell.new-cell {
            opacity: 0;
            transform: translateY(-30px) scale(0.5);
            animation: newCellAppear 0.5s forwards cubic-bezier(0.4, 0, 0.2, 1);
        }
        @keyframes newCellAppear {
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* --- パーティクル --- */
        .particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #ffd180;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            opacity: 1;
            animation: particle-effect 0.8s forwards ease-out;
        }
        @keyframes particle-effect {
            0% { transform: translate(0, 0) scale(1) rotate(0deg); opacity: 1; background-color: #ffe0b2; }
            50% { transform: translate(var(--particle-mid-x), var(--particle-mid-y)) scale(1.5) rotate(180deg); opacity: 0.8; background-color: #ffb74d; }
            100% { transform: translate(var(--particle-x), var(--particle-y)) scale(0) rotate(360deg); opacity: 0; }
        }

        /* --- UI要素 --- */
        #mission-display {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            color: #ec407a;
            min-height: 3em;
        }
        #score-display {
            font-size: 1rem;
            margin-bottom: 12px;
        }
        #message-area {
            min-height: 1.5em;
            margin-top: 10px;
            font-weight: bold;
            color: #4db6ac;
        }
        #controls-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .action-button {
            background-color: #f06292;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .action-button:hover {
            background-color: #e91e63;
        }
        #version-display {
            position: absolute;
            bottom: 5px;
            left: 10px;
            font-size: 0.75rem;
            color: #bcaaa4;
        }

        /* --- 更新通知 --- */
        #update-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4db6ac;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            text-align: center;
        }
        #update-notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        #update-button {
            background-color: #ffffff;
            color: #4db6ac;
            border: none;
            padding: 5px 15px;
            margin-left: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        #update-button:hover {
            background-color: #f0fdfa;
        }

        /* --- レスポンシブ対応 --- */
        @media (max-width: 360px) {
            .cell { font-size: 1.25rem; }
            #mission-display { font-size: 0.9rem; }
            .action-button { padding: 8px 12px; font-size: 0.8rem; }
            .particle { width: 8px; height: 8px; }
            #version-display { font-size: 0.65rem; left: 5px; }
            #update-notification { width: calc(100% - 20px); top: 10px; left: 10px; right: 10px; transform: none; font-size: 0.8rem; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
</head>
<body>
    <div id="update-notification">
        新しいバージョンが利用可能です！
        <button id="update-button">更新</button>
    </div>

    <div id="game-container">
        <div id="mission-display">ミッションを読み込み中...</div>
        <div id="score-display">スコア: <span id="score">0</span></div>
        <div id="game-board">
            <div id="glow-layer"></div>
            <div id="grid-area">
                <canvas id="line-canvas"></canvas>
                <div id="grid-container"></div>
            </div>
        </div>
        <div id="message-area"></div>
        <div id="controls-area">
            <button id="give-up-button" class="action-button">ギブアップ</button>
            <button id="manual-check-update-button" class="action-button">更新を確認</button> </div>
        <div id="version-display">ver1.17</div> </div>

    <script>
        // --- 定数とグローバル変数 ---
        const GRID_SIZE = 4;
        const MIN_NUM = 1;
        const MAX_NUM = 9;
        const TARGET_MISSIONS_PER_LEVEL = 10;
        const DEBUG_SHOW_COLLISION_CIRCLES = false;
        const NUM_PARTICLES_PER_CELL = 12;
        const PARTICLE_BASE_SIZE_PX = 12;

        const gridContainer = document.getElementById('grid-container');
        const lineCanvas = document.getElementById('line-canvas');
        const canvasCtx = lineCanvas.getContext('2d');
        const missionDisplay = document.getElementById('mission-display');
        const scoreDisplay = document.getElementById('score');
        const messageArea = document.getElementById('message-area');
        const giveUpButton = document.getElementById('give-up-button');
        const gridArea = document.getElementById('grid-area');
        const glowLayer = document.getElementById('glow-layer');
        const updateNotification = document.getElementById('update-notification');
        const updateButton = document.getElementById('update-button');
        const manualCheckUpdateButton = document.getElementById('manual-check-update-button');

        const selectSounds = [ new Howl({ src: ['sounds/se1.mp3'], volume: 0.7 }) ];
        const successSound = new Howl({ src: ['sounds/success.mp3'] });
        const failureSound = new Howl({ src: ['sounds/failure.mp3'] });
        const clearSound = new Howl({ src: ['sounds/clear.mp3'] });

        let cellsData = [];
        let selectedCells = [];
        let currentMission = { type: 'sum', target: 0, text: "" };
        let score = 0;
        let isDrawing = false;
        let missionsSinceLastLevelUp = 0;
        let currentLevel = 1;
        let newWorker = null; 
        let refreshing = false; 

        // (他の関数は変更なし)
        function initGame() {
            gridContainer.innerHTML = '';
            cellsData = [];
            document.querySelectorAll('.debug-collision-circle').forEach(el => el.remove());
            document.querySelectorAll('.particle').forEach(el => el.remove());
            missionsSinceLastLevelUp = 0;
            currentLevel = 1;
            score = 0;
            currentMission.target = 0;
            for (let r = 0; r < GRID_SIZE; r++) {
                const rowData = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellValue = Math.floor(Math.random() * (MAX_NUM - MIN_NUM + 1)) + MIN_NUM;
                    const cellElement = createCellElement(r, c, cellValue);
                    const cellObj = { value: cellValue, element: cellElement, row: r, col: c, id: `cell-${r}-${c}-${Date.now()}`, centerX: 0, centerY: 0, collisionRadius: 0 };
                    gridContainer.appendChild(cellElement);
                    rowData.push(cellObj);
                }
                cellsData.push(rowData);
            }
            resizeCanvasAndCells(); 
            updateAllCellDisplays();
            generateNewMission();
            updateScoreDisplay();
            clearSelection();
        }

        function createCellElement(row, col, value) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.row = row;
            cell.dataset.col = col;
            return cell;
        }

        function updateAllCellDisplays() {
            if (!cellsData || cellsData.length === 0) return;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellObj = cellsData[r][c];
                    if (cellObj && cellObj.element) {
                         cellObj.element.textContent = cellObj.value === null ? '' : cellObj.value.toString();
                    }
                }
            }
        }

        function resizeCanvasAndCells() {
            const gridRect = gridContainer.getBoundingClientRect();
            lineCanvas.width = gridRect.width;
            lineCanvas.height = gridRect.height;
            document.querySelectorAll('.debug-collision-circle').forEach(el => el.remove());
            if (!cellsData || cellsData.length === 0) return;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellObj = cellsData[r][c];
                    if (!cellObj || !cellObj.element) continue;
                    const cellRect = cellObj.element.getBoundingClientRect();
                    cellObj.centerX = (cellRect.left - gridRect.left) + (cellRect.width / 2);
                    cellObj.centerY = (cellRect.top - gridRect.top) + (cellRect.height / 2);
                    cellObj.collisionRadius = cellRect.width * 0.40;
                }
            }
            drawLines();
        }

        function updateMissionDisplay() {
            missionDisplay.textContent = `レベル ${currentLevel} (${missionsSinceLastLevelUp}/${TARGET_MISSIONS_PER_LEVEL}) - ${currentMission.text || 'ミッション準備中...'}`;
        }

        function generateNewMission() {
            let targetValue;
            let missionText = "";
            if (missionsSinceLastLevelUp === 0 || currentMission.target === 0) {
                let availableCells = cellsData.flat().filter(c => c && c.value !== null);
                if (availableCells.length < 2) {
                    currentMission = { type: 'sum', target: 0, text: "数字が足りません！" };
                    updateMissionDisplay();
                    return;
                }
                let numToPick = Math.floor(Math.random() * 2) + 2;
                numToPick = Math.min(numToPick, availableCells.length);
                let potentialSolutionCells = [];
                for(let i=0; i<numToPick; i++) {
                     if(availableCells.length === 0) break;
                    potentialSolutionCells.push(availableCells.splice(Math.floor(Math.random() * availableCells.length), 1)[0]);
                }
                if (potentialSolutionCells.length < 2) {
                     currentMission = { type: 'sum', target: 0, text: "ミッション作成不可" };
                     updateMissionDisplay();
                     return;
                }
                targetValue = potentialSolutionCells.reduce((acc, cell) => acc + cell.value, 0);
                if (targetValue > 50 && potentialSolutionCells.length > 2) targetValue = Math.floor(Math.random() * 30) + 10;
                else if (targetValue > 30 && potentialSolutionCells.length === 2) targetValue = Math.floor(Math.random() * 20) + 5;
                else if (targetValue < 5) targetValue = Math.floor(Math.random() * 5) + 5;
                currentMission.target = targetValue;
            }
            currentMission.type = 'sum';
            currentMission.text = `合計して ${currentMission.target} にしよう！`;
            updateMissionDisplay();
        }

        function checkMission() {
            if (selectedCells.length < 2) return false;
            const values = selectedCells.map(cell => cell.value);
            const result = values.reduce((acc, val) => acc + val, 0);
            return result === currentMission.target;
        }

        function handleInteractionStart(event) {
            if (gridContainer.contains(event.target) || event.target === gridContainer) event.preventDefault();
            clearSelection();
            isDrawing = true;
            addCellToSelection(event);
        }

        function handleInteractionMove(event) {
            if (!isDrawing) return;
            if (gridContainer.contains(event.target) || event.target === gridContainer || event.type === 'touchmove') event.preventDefault();
            addCellToSelection(event);
        }

        function handleInteractionEnd(event) {
            if (!isDrawing) return;
            isDrawing = false;
            if (checkMission()) {
                messageArea.textContent = "ミッション成功！";
                score += selectedCells.length * 10;
                updateScoreDisplay();
                missionsSinceLastLevelUp++;
                if (missionsSinceLastLevelUp >= TARGET_MISSIONS_PER_LEVEL) {
                    currentLevel++;
                    missionsSinceLastLevelUp = 0;
                    currentMission.target = 0;
                    messageArea.textContent = `レベル ${currentLevel -1} クリア！レベル ${currentLevel} スタート！`;
                }
                processClearedCells();
            } else {
                if (selectedCells.length > 0) {
                    messageArea.textContent = "残念！もう一度挑戦。";
                    setTimeout(() => {
                        clearSelection();
                        if (messageArea.textContent === "残念！もう一度挑戦。") messageArea.textContent = "";
                    }, 1000);
                } else {
                    clearSelection();
                }
            }
        }

        function handleGiveUp() {
            clearSelection();
            currentLevel++;
            missionsSinceLastLevelUp = 0;
            currentMission.target = 0;
            generateNewMission();
            messageArea.textContent = `次のレベル (${currentLevel}) に進みます！`;
            setTimeout(() => {
                if (messageArea.textContent === `次のレベル (${currentLevel}) に進みます！`) messageArea.textContent = "";
            }, 2000);
        }

        function addCellToSelection(event) {
            const targetCellData = getCellFromEvent(event);
            if (!targetCellData || selectedCells.find(sc => sc.id === targetCellData.id)) return;
            if (selectedCells.length > 0) {
                const lastCell = selectedCells[selectedCells.length - 1];
                const rowDiff = Math.abs(lastCell.row - targetCellData.row);
                const colDiff = Math.abs(lastCell.col - targetCellData.col);
                if (rowDiff > 1 || colDiff > 1) return;
            }
            selectedCells.push(targetCellData);
            if(targetCellData.element) targetCellData.element.classList.add('selected');
            if (glowLayer && targetCellData.element) {
                const cellElem = targetCellData.element;
                const glowNode = document.createElement('div');
                glowNode.classList.add('glow-node');
                const gridContainerStyle = window.getComputedStyle(gridContainer);
                const gridPaddingLeft = parseFloat(gridContainerStyle.left) || 0;
                const gridPaddingTop = parseFloat(gridContainerStyle.top) || 0;
                const cellLeft = cellElem.offsetLeft + gridPaddingLeft;
                const cellTop = cellElem.offsetTop + gridPaddingTop;
                glowNode.style.width = `${cellElem.offsetWidth}px`;
                glowNode.style.height = `${cellElem.offsetHeight}px`;
                glowNode.style.left = `${cellLeft}px`;
                glowNode.style.top = `${cellTop}px`;
                glowLayer.appendChild(glowNode);
            }
            try {
                const soundIndex = Math.min(selectedCells.length - 1, selectSounds.length - 1);
                selectSounds[soundIndex].play();
            } catch (e) {
                console.error("サウンドの再生に失敗しました: ", e);
            }
            drawLines();
        }

        function getCellFromEvent(event) {
            const gridRect = gridContainer.getBoundingClientRect();
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            const pointerX = clientX - gridRect.left;
            const pointerY = clientY - gridRect.top;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = cellsData[r][c];
                    if (!cell) continue;
                    const distance = Math.sqrt(Math.pow(pointerX - cell.centerX, 2) + Math.pow(pointerY - cell.centerY, 2));
                    if (distance < cell.collisionRadius) return cell;
                }
            }
            return null;
        }

        function clearSelection() {
            selectedCells.forEach(cell => {
                if (cell && cell.element) cell.element.classList.remove('selected');
            });
            selectedCells = [];
            clearCanvas();
            if (glowLayer) glowLayer.innerHTML = '';
        }

        function drawLines() {
            clearCanvas();
            if (selectedCells.length < 2) return;
            canvasCtx.beginPath();
            canvasCtx.strokeStyle = '#ff80ab';
            canvasCtx.lineWidth = Math.max(3, gridContainer.offsetWidth / 70);
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';
            for (let i = 0; i < selectedCells.length; i++) {
                const cell = selectedCells[i];
                if (i === 0) canvasCtx.moveTo(cell.centerX, cell.centerY);
                else canvasCtx.lineTo(cell.centerX, cell.centerY);
            }
            canvasCtx.stroke();
        }

        function clearCanvas() {
            canvasCtx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
        }

        function createParticles(cell) {
            if (!cell || !gridArea) return;
            const startX = cell.centerX;
            const startY = cell.centerY;
            for (let i = 0; i < NUM_PARTICLES_PER_CELL; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                const particleSize = PARTICLE_BASE_SIZE_PX;
                particle.style.left = `${startX - particleSize / 2}px`;
                particle.style.top = `${startY - particleSize / 2}px`;
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 60 + 30;
                const midDistance = distance * 0.5;
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                const midX = Math.cos(angle) * midDistance;
                const midY = Math.sin(angle) * midDistance;
                particle.style.setProperty('--particle-x', `${endX}px`);
                particle.style.setProperty('--particle-y', `${endY}px`);
                particle.style.setProperty('--particle-mid-x', `${midX}px`);
                particle.style.setProperty('--particle-mid-y', `${midY}px`);
                particle.style.animationDelay = `${Math.random() * 0.25}s`;
                gridArea.appendChild(particle);
                particle.addEventListener('animationend', () => particle.remove());
            }
        }
        
        // ▼▼▼ 修正した関数 ▼▼▼
        async function processClearedCells() {
            const cellsToClear = [...selectedCells]; // 消去するセルを保存

            // 選択の視覚効果（光、線、ハイライト）を先に消去する
            clearSelection();

            clearSound.play();
            cellsToClear.forEach(cell => createParticles(cell));

            // 消去アニメーションの実行
            const removalPromises = cellsToClear.map(cell => {
                if(cell && cell.element) {
                    cell.element.classList.add('clearing');
                    return new Promise(resolve => setTimeout(resolve, 600));
                }
                return Promise.resolve();
            });
            await Promise.all(removalPromises);

            // データからセルを削除
            cellsToClear.forEach(clearedCell => {
                if (clearedCell?.row !== undefined && clearedCell?.col !== undefined && cellsData[clearedCell.row]?.[clearedCell.col]) {
                    cellsData[clearedCell.row][clearedCell.col].value = null;
                    if(clearedCell.element) {
                        clearedCell.element.classList.remove('clearing');
                    }
                }
            });
            
            await applyGravityAndRefill();
            generateNewMission();
        }
        // ▲▲▲ 修正ここまで ▲▲▲

        async function applyGravityAndRefill() {
            const animationPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySlotsInCol = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (!cellsData[r]?.[c]) continue;
                    const currentCellData = cellsData[r][c];
                    if (currentCellData.value === null) {
                        emptySlotsInCol++;
                    } else if (emptySlotsInCol > 0) {
                        const newRow = r + emptySlotsInCol;
                        const cellToMove = cellsData[r][c];
                        if (!cellToMove.element) continue;
                        const cellHeight = cellToMove.element.offsetHeight;
                        const gap = parseFloat(window.getComputedStyle(gridContainer).gap) || 8;
                        const fallDistance = emptySlotsInCol * (cellHeight + gap);
                        cellToMove.element.style.transform = `translateY(${fallDistance}px)`;
                        cellToMove.element.classList.add('falling');
                        cellsData[newRow][c] = cellToMove;
                        cellsData[r][c] = { value: null, element: cellsData[r][c].element, row: r, col: c, id: `empty-temp-${r}-${c}-${Date.now()}` };
                        cellToMove.row = newRow;
                        animationPromises.push(new Promise(resolve => {
                            setTimeout(() => {
                                if (cellToMove.element) {
                                    cellToMove.element.style.transform = '';
                                    cellToMove.element.classList.remove('falling');
                                }
                                resolve();
                            }, 500);
                        }));
                    }
                }
                for (let i = 0; i < emptySlotsInCol; i++) {
                    const cellToFill = cellsData[i][c];
                    if (!cellToFill?.element) continue;
                    cellToFill.value = Math.floor(Math.random() * (MAX_NUM - MIN_NUM + 1)) + MIN_NUM;
                    cellToFill.element.classList.add('new-cell');
                    animationPromises.push(new Promise(resolve => {
                        setTimeout(() => {
                            cellToFill.element?.classList.remove('new-cell');
                            resolve();
                        }, 500);
                    }));
                }
            }
            await Promise.all(animationPromises);
            const tempGridDataValuesOnly = cellsData.map(row => row.map(cell => ({ value: cell.value })));
            gridContainer.innerHTML = '';
            const newMasterCellsData = [];
            for(let r=0; r<GRID_SIZE; r++) {
                const newRowData = [];
                for(let c=0; c<GRID_SIZE; c++) {
                    const valueToSet = tempGridDataValuesOnly[r][c].value;
                    const newElement = createCellElement(r,c, valueToSet);
                    gridContainer.appendChild(newElement);
                    newRowData.push({ value: valueToSet, element: newElement, row: r, col: c, id: `cell-${r}-${c}-${Date.now()}` });
                }
                newMasterCellsData.push(newRowData);
            }
            cellsData = newMasterCellsData;
            resizeCanvasAndCells();
            updateAllCellDisplays();
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = score;
        }

        // --- Service Worker etc. (変更なし) ---
        function showUpdateNotification() { updateNotification.classList.add('show'); }
        function hideUpdateNotification() { updateNotification.classList.remove('show'); }
        function handleUpdate() { if (newWorker) newWorker.postMessage({ action: 'skipWaiting' }); hideUpdateNotification(); }
        function trackInstalling(worker) {
            worker.addEventListener('statechange', () => {
                if (worker.state === 'installed') {
                    if (navigator.serviceWorker.controller) {
                        newWorker = worker;
                        showUpdateNotification();
                    }
                }
            });
        }
        const eventAreaForInteraction = document.getElementById('grid-area');
        eventAreaForInteraction.addEventListener('mousedown', handleInteractionStart);
        document.addEventListener('mousemove', handleInteractionMove);
        document.addEventListener('mouseup', handleInteractionEnd);
        eventAreaForInteraction.addEventListener('touchstart', handleInteractionStart, { passive: false });
        document.addEventListener('touchmove', handleInteractionMove, { passive: false });
        document.addEventListener('touchend', handleInteractionEnd);
        document.addEventListener('touchcancel', handleInteractionEnd);
        giveUpButton.addEventListener('click', handleGiveUp);
        updateButton.addEventListener('click', handleUpdate);
        window.addEventListener('resize', resizeCanvasAndCells);
		if (manualCheckUpdateButton) {
		    manualCheckUpdateButton.addEventListener('click', () => {
		        messageArea.textContent = "";
		        if (!navigator.serviceWorker?.getRegistration) {
		            messageArea.textContent = "Service Workerが利用できません。";
		            return;
		        }
		        navigator.serviceWorker.getRegistration().then(registration => {
		            if (!registration) {
		                messageArea.textContent = "更新チェック機能が有効ではありません。";
		                return;
		            }
		            if (registration.waiting) {
		                newWorker = registration.waiting;
		                messageArea.textContent = "新しいバージョンが待機中です！";
		                showUpdateNotification();
		                return;
		            }
		            messageArea.textContent = "更新を確認中...";
		            registration.update().then(updatedReg => {
		                if (updatedReg.installing) {
		                    messageArea.textContent = "新しいバージョンをインストール中...";
		                    if (!newWorker || newWorker !== updatedReg.installing) {
		                       newWorker = updatedReg.installing;
		                       trackInstalling(newWorker);
		                    }
		                } else if (updatedReg.waiting) {
		                    newWorker = updatedReg.waiting;
		                    messageArea.textContent = "新しいバージョンが見つかりました！";
		                    showUpdateNotification();
		                } else {
		                    messageArea.textContent = "現在、最新バージョンです。";
		                }
		            }).catch(err => messageArea.textContent = "更新チェックに失敗しました。");
		        }).catch(err => messageArea.textContent = "更新機能の状態取得に失敗しました。");
		    });
		}
        initGame();
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js', { scope: './' }).then(registration => {
                    if (registration.waiting) { newWorker = registration.waiting; showUpdateNotification(); }
                    if (registration.installing) { trackInstalling(registration.installing); }
                    registration.addEventListener('updatefound', () => trackInstalling(registration.installing));
                }).catch(error => console.error('Service Worker registration failed:', error));
                let refreshingReloadFlag;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshingReloadFlag) return;
                    window.location.reload();
                    refreshingReloadFlag = true;
                });
            });
        }
    </script>
</body>
</html>