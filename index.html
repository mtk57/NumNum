<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple Number Connect</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SimpleNumConnect">
    <link rel="apple-touch-icon" href="icons/icon-180x180.png">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-300 */
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Prevent default touch actions like pull-to-refresh */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748; /* Tailwind gray-800 */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 400px; /* Max width of the game container */
            box-sizing: border-box;
            position: relative; /* Added for version display positioning */
        }
        #mission-display {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            color: #90cdf4; /* Tailwind blue-400 */
            min-height: 3em;
        }
        #score-display {
            font-size: 1rem;
            margin-bottom: 12px;
        }
        #grid-area {
            position: relative;
            width: calc(100% - 10px); /* Adjust for padding/border */
            max-width: 320px; /* Max size for the grid itself */
            aspect-ratio: 1 / 1; /* Make it square */
            margin-bottom: 15px;
            overflow: hidden; /* Prevent particles from showing outside */
        }
        #grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* GRID_SIZE will be 4 */
            grid-template-rows: repeat(4, 1fr);   /* GRID_SIZE will be 4 */
            gap: 8px;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        .cell {
            background-color: #4a5568; /* Tailwind gray-600 */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.75rem;
            font-weight: bold;
            color: #edf2f7; /* Tailwind gray-200 */
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease, opacity 0.3s ease;
            position: relative;
            aspect-ratio: 1 / 1;
        }
        .cell.selected {
            background-color: #63b3ed; /* Tailwind blue-400 */
            transform: scale(1.15); /* Slightly larger selection indication */
            color: #1a202c;
            box-shadow: 0 0 15px #63b3ed, 0 0 25px #63b3ed; /* Glow effect */
        }
        .cell.clearing {
            animation: cellClearEffect 0.6s forwards ease-out;
        }
        @keyframes cellClearEffect {
            0% {
                opacity: 1;
                transform: scale(1.1) rotate(0deg);
                background-color: #fbd38d;
            }
            50% {
                transform: scale(1.3) rotate(180deg);
                opacity: 0.7;
            }
            100% {
                opacity: 0;
                transform: scale(0.3) rotate(360deg);
                background-color: #fbd38d;
            }
        }
        .cell.falling {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .cell.new-cell {
            opacity: 0;
            transform: translateY(-30px) scale(0.5);
            animation: newCellAppear 0.5s forwards cubic-bezier(0.4, 0, 0.2, 1);
        }
        @keyframes newCellAppear {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .debug-collision-circle {
            position: absolute;
            border: 1px dashed rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
            box-sizing: border-box;
        }
        #line-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* Particle styles */
        .particle {
            position: absolute;
            width: 12px; /* Increased size */
            height: 12px; /* Increased size */
            background-color: #fbd38d; /* Tailwind orange-300 */
            border-radius: 50%;
            pointer-events: none;
            z-index: 4; /* Above cells and lines */
            opacity: 1;
            animation: particle-effect 0.8s forwards ease-out; /* Slightly longer animation */
        }

        @keyframes particle-effect {
            0% {
                transform: translate(0, 0) scale(1) rotate(0deg);
                opacity: 1;
                background-color: #fee2b3; /* Lighter orange */
            }
            50% {
                transform: translate(var(--particle-mid-x), var(--particle-mid-y)) scale(1.5) rotate(180deg);
                opacity: 0.8;
                background-color: #f6ad55; /* Darker orange */
            }
            100% {
                transform: translate(var(--particle-x), var(--particle-y)) scale(0) rotate(360deg);
                opacity: 0;
                background-color: #fbd38d;
            }
        }

        #message-area {
            min-height: 1.5em;
            margin-top: 10px;
            font-weight: bold;
            color: #68d391; /* Tailwind green-400 */
        }
        #controls-area {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .action-button {
            background-color: #4299e1; /* Tailwind blue-500 */
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .action-button:hover {
            background-color: #3182ce; /* Tailwind blue-600 */
        }

        #version-display {
            position: absolute;
            bottom: 5px;
            left: 10px;
            font-size: 0.75rem;
            color: #a0aec0; /* Tailwind gray-500 */
        }

        /* Update notification styles */
        #update-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #38a169; /* Tailwind green-600 */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            text-align: center;
        }

        #update-notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #update-button {
            background-color: #2d3748;
            color: white;
            border: none;
            padding: 5px 15px;
            margin-left: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        #update-button:hover {
            background-color: #1a202c;
        }

        @media (max-width: 360px) {
            .cell {
                font-size: 1.25rem;
            }
            #mission-display {
                font-size: 0.9rem;
            }
             .action-button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            .particle {
                width: 8px; /* Adjusted for smaller screens */
                height: 8px;
            }
            #version-display {
                font-size: 0.65rem;
                left: 5px;
            }
            #update-notification {
                top: 10px;
                left: 10px;
                right: 10px;
                transform: none;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="update-notification">
        新しいバージョンが利用可能です！
        <button id="update-button">更新</button>
    </div>

    <div id="game-container">
        <div id="mission-display">ミッションを読み込み中...</div>
        <div id="score-display">スコア: <span id="score">0</span></div>
        <div id="grid-area">
            <canvas id="line-canvas"></canvas>
            <div id="grid-container"></div>
        </div>
        <div id="message-area"></div>
        <div id="controls-area">
            <button id="give-up-button" class="action-button">ギブアップ</button>
        </div>
        <div id="version-display">ver 0.9</div>
    </div>

    <script>
        const GRID_SIZE = 4;
        const MIN_NUM = 1;
        const MAX_NUM = 9;
        const TARGET_MISSIONS_PER_LEVEL = 10;
        const DEBUG_SHOW_COLLISION_CIRCLES = false;
        const NUM_PARTICLES_PER_CELL = 12; // Increased number of particles
        const PARTICLE_BASE_SIZE_PX = 12; // Base particle size from CSS (default, not responsive yet)

        const gridContainer = document.getElementById('grid-container');
        const lineCanvas = document.getElementById('line-canvas');
        const canvasCtx = lineCanvas.getContext('2d');
        const missionDisplay = document.getElementById('mission-display');
        const scoreDisplay = document.getElementById('score');
        const messageArea = document.getElementById('message-area');
        const giveUpButton = document.getElementById('give-up-button');
        const gridArea = document.getElementById('grid-area');
        const updateNotification = document.getElementById('update-notification');
        const updateButton = document.getElementById('update-button');

        let cellsData = [];
        let selectedCells = [];
        let currentMission = { type: 'sum', target: 0, text: "" };
        let score = 0;
        let isDrawing = false;
        let missionsSinceLastLevelUp = 0;
        let currentLevel = 1;

        // Service Worker variables
        let newWorker = null;

        // Initialize the game
        function initGame() {
            gridContainer.innerHTML = '';
            cellsData = [];
            document.querySelectorAll('.debug-collision-circle').forEach(el => el.remove());
            document.querySelectorAll('.particle').forEach(el => el.remove());

            missionsSinceLastLevelUp = 0;
            currentLevel = 1;
            score = 0;
            currentMission.target = 0;

            for (let r = 0; r < GRID_SIZE; r++) {
                const rowData = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellValue = Math.floor(Math.random() * (MAX_NUM - MIN_NUM + 1)) + MIN_NUM;
                    const cellElement = createCellElement(r, c, cellValue);

                    const cellObj = {
                        value: cellValue,
                        element: cellElement,
                        row: r,
                        col: c,
                        id: `cell-${r}-${c}-${Date.now()}`, // Unique ID for each cell instance
                        centerX: 0, // Will be calculated on resize/init
                        centerY: 0, // Will be calculated on resize/init
                        collisionRadius: 0 // Will be calculated on resize/init
                    };
                    gridContainer.appendChild(cellElement);
                    rowData.push(cellObj);
                }
                cellsData.push(rowData);
            }
            resizeCanvasAndCells(); // Calculate initial positions and sizes
            updateAllCellDisplays();
            generateNewMission();
            updateScoreDisplay();
            clearSelection();
            window.addEventListener('resize', resizeCanvasAndCells);
        }

        // Create a single cell DOM element
        function createCellElement(row, col, value) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.row = row;
            cell.dataset.col = col;
            // Value will be set by updateAllCellDisplays
            return cell;
        }

        // Update the text content of all cells based on cellsData
        function updateAllCellDisplays() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellObj = cellsData[r][c];
                    if (cellObj && cellObj.element) {
                         cellObj.element.textContent = cellObj.value === null ? '' : cellObj.value.toString();
                    }
                }
            }
        }

        // Recalculate canvas size and cell positions/collision areas
        function resizeCanvasAndCells() {
            const gridRect = gridContainer.getBoundingClientRect();
            lineCanvas.width = gridRect.width;
            lineCanvas.height = gridRect.height;

            // Clear old debug circles if any
            document.querySelectorAll('.debug-collision-circle').forEach(el => el.remove());

            if (!cellsData || cellsData.length === 0) return;

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellObj = cellsData[r][c];
                    if (!cellObj || !cellObj.element) continue;

                    const cellRect = cellObj.element.getBoundingClientRect();

                    // Calculate center relative to the gridContainer
                    cellObj.centerX = (cellRect.left - gridRect.left) + (cellRect.width / 2);
                    cellObj.centerY = (cellRect.top - gridRect.top) + (cellRect.height / 2);
                    // Adjust collision radius for better touch accuracy (e.g., 40% of width)
                    cellObj.collisionRadius = cellRect.width * 0.40;

                    if (DEBUG_SHOW_COLLISION_CIRCLES) {
                        const debugCircle = document.createElement('div');
                        debugCircle.classList.add('debug-collision-circle');
                        debugCircle.style.width = `${cellObj.collisionRadius * 2}px`;
                        debugCircle.style.height = `${cellObj.collisionRadius * 2}px`;
                        debugCircle.style.left = `${cellObj.centerX - cellObj.collisionRadius}px`;
                        debugCircle.style.top = `${cellObj.centerY - cellObj.collisionRadius}px`;
                        gridArea.appendChild(debugCircle); // Append to gridArea for correct positioning
                    }
                }
            }
            drawLines(); // Redraw lines if any selection exists
        }


        // Update the mission display text
        function updateMissionDisplay() {
            if (currentMission && currentMission.text) {
                missionDisplay.textContent = `レベル ${currentLevel} (${missionsSinceLastLevelUp}/${TARGET_MISSIONS_PER_LEVEL}) - ${currentMission.text}`;
            } else {
                missionDisplay.textContent = `レベル ${currentLevel} (${missionsSinceLastLevelUp}/${TARGET_MISSIONS_PER_LEVEL}) - ミッション準備中...`;
            }
        }

        // Generate a new mission
        function generateNewMission() {
            let targetValue;
            let missionText = "";

            // Only generate a completely new target if it's the start of a level or previous mission was invalid
            if (missionsSinceLastLevelUp === 0 || currentMission.target === 0) {
                let potentialSolutionCells = [];
                let availableCells = cellsData.flat().filter(c => c && c.value !== null);

                if (availableCells.length < 2) {
                    missionText = "数字が足りません！"; // Not enough numbers to form a mission
                    currentMission = { type: 'sum', target: 0, text: missionText };
                    updateMissionDisplay();
                    return;
                }

                // Try to pick 2 or 3 cells for the sum
                let numToPick = Math.floor(Math.random() * 2) + 2; // 2 or 3
                numToPick = Math.min(numToPick, availableCells.length); // Don't pick more than available

                // Randomly pick cells for the sum
                for(let i=0; i<numToPick; i++) {
                     if(availableCells.length === 0) break; // Should not happen if initial check passes
                    potentialSolutionCells.push(availableCells.splice(Math.floor(Math.random() * availableCells.length), 1)[0]);
                }

                // Fallback if somehow not enough cells were picked but grid has enough
                if (potentialSolutionCells.length < 2 && cellsData.flat().filter(c => c && c.value !== null).length >=2) {
                     potentialSolutionCells = cellsData.flat().filter(c => c && c.value !== null).slice(0,2); // Pick first two
                } else if (potentialSolutionCells.length < 2) {
                     missionText = "ミッション作成不可"; // Cannot create mission
                     currentMission = { type: 'sum', target: 0, text: missionText };
                     updateMissionDisplay();
                     return;
                }


                targetValue = potentialSolutionCells.reduce((acc, cell) => acc + cell.value, 0);
                // Adjust target if it's too high or too low to be interesting
                if (targetValue > 50 && potentialSolutionCells.length > 2) targetValue = Math.floor(Math.random() * 30) + 10; // Cap for 3+ cells
                else if (targetValue > 30 && potentialSolutionCells.length === 2) targetValue = Math.floor(Math.random() * 20) + 5; // Cap for 2 cells
                else if (targetValue < 5) targetValue = Math.floor(Math.random() * 5) + 5; // Min target sum

                currentMission.target = targetValue;
            }
            // For now, only sum missions
            currentMission.type = 'sum';
            missionText = `合計して ${currentMission.target} にしよう！`;
            currentMission.text = missionText;
            updateMissionDisplay();
        }


        // Check if the current selection meets the mission criteria
        function checkMission() {
            if (selectedCells.length < 2) return false; // Need at least 2 cells

            const values = selectedCells.map(cell => cell.value);
            const result = values.reduce((acc, val) => acc + val, 0);

            return result === currentMission.target;
        }

        // Handle start of interaction (mousedown or touchstart)
        function handleInteractionStart(event) {
            // Prevent default only if target is within grid or is the grid itself to allow page scroll otherwise
            if (gridContainer.contains(event.target) || event.target === gridContainer) {
                 event.preventDefault();
            }
            clearSelection();
            isDrawing = true;
            addCellToSelection(event);
        }

        // Handle movement during interaction (mousemove or touchmove)
        function handleInteractionMove(event) {
            if (!isDrawing) return;
             // Prevent default for touchmove to avoid scrolling while drawing
             if (gridContainer.contains(event.target) || event.target === gridContainer || event.type === 'touchmove') { // Added event.type check
                event.preventDefault();
            }
            addCellToSelection(event);
        }

        // Handle end of interaction (mouseup or touchend)
        function handleInteractionEnd(event) {
            if (!isDrawing && selectedCells.length === 0) { // No drawing was happening and nothing selected
                clearSelection();
                return;
            }
            if (isDrawing) { // If drawing was active, now it's not
                isDrawing = false;
            } else { // If not drawing but some cells were selected (e.g. quick tap then release)
                 if (selectedCells.length === 0) return; // Nothing to process
            }


            if (checkMission()) {
                messageArea.textContent = "ミッション成功！";
                score += selectedCells.length * 10; // Score based on number of cells
                updateScoreDisplay();
                drawLines(); // Keep lines visible until cells clear

                missionsSinceLastLevelUp++;
                if (missionsSinceLastLevelUp >= TARGET_MISSIONS_PER_LEVEL) {
                    currentLevel++;
                    missionsSinceLastLevelUp = 0;
                    currentMission.target = 0; // Force new mission target for new level
                    messageArea.textContent = `レベル ${currentLevel -1} クリア！レベル ${currentLevel} スタート！`;
                }
                processClearedCells();
            } else {
                if (selectedCells.length > 0) { // Only show "try again" if something was selected
                    messageArea.textContent = "残念！もう一度挑戦。";
                    setTimeout(() => {
                        clearSelection(); // Clear selection after a delay
                        if (messageArea.textContent === "残念！もう一度挑戦。") { // Clear message if it hasn't changed
                             messageArea.textContent = "";
                        }
                    }, 1000);
                } else {
                    clearSelection(); // If nothing was selected, just clear (redundant but safe)
                }
            }

            // Clear non-persistent messages after a delay
            const levelUpMessage = `レベル ${currentLevel -1} クリア！レベル ${currentLevel} スタート！`;
            if (messageArea.textContent !== levelUpMessage && messageArea.textContent !== "残念！もう一度挑戦。") {
                setTimeout(() => {
                    if (messageArea.textContent !== levelUpMessage && messageArea.textContent !== "残念！もう一度挑戦。") {
                        messageArea.textContent = "";
                    }
                }, 2000);
            }
        }

        // Handle "Give Up" button click
        function handleGiveUp() {
            clearSelection();
            currentLevel++; // Advance to next level
            missionsSinceLastLevelUp = 0;
            currentMission.target = 0; // Force new mission target for new level

            generateNewMission(); // Generate a mission for the new level
            messageArea.textContent = `次のレベル (${currentLevel}) に進みます！`;
            setTimeout(() => {
                if (messageArea.textContent === `次のレベル (${currentLevel}) に進みます！`) {
                    messageArea.textContent = "";
                }
            }, 2000);
        }
        giveUpButton.addEventListener('click', handleGiveUp);


        // Add a cell to the current selection path
        function addCellToSelection(event) {
            const targetCellData = getCellFromEvent(event);
            if (!targetCellData) return; // No cell found at pointer/touch location

            if (selectedCells.length > 0) {
                const lastCell = selectedCells[selectedCells.length - 1];
                // Don't add if it's the same as the last cell
                if (lastCell.id === targetCellData.id) return;

                // *** MODIFIED: Allow diagonal connections ***
                const rowDiff = Math.abs(lastCell.row - targetCellData.row);
                const colDiff = Math.abs(lastCell.col - targetCellData.col);

                // If the difference in row or column is greater than 1, it's not adjacent.
                // This allows horizontal, vertical, and diagonal connections (rowDiff <= 1 && colDiff <= 1)
                if (rowDiff > 1 || colDiff > 1) {
                    return; // Not adjacent (neither cardinally nor diagonally)
                }
            }

            // Check if this cell is already in the current selection path (to prevent loops)
            const alreadySelectedInPath = selectedCells.find(sc => sc.id === targetCellData.id);
            if (alreadySelectedInPath) return; // Already selected in this path

            selectedCells.push(targetCellData);
            if(targetCellData.element) targetCellData.element.classList.add('selected');
            drawLines();
        }

        // Get cell data object from a browser event (mouse or touch)
        function getCellFromEvent(event) {
            const gridRect = gridContainer.getBoundingClientRect();
            let clientX, clientY;

            // Determine coordinates from event type
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) { // For touchend
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            }
            else { // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Calculate pointer position relative to the grid container
            const pointerX = clientX - gridRect.left;
            const pointerY = clientY - gridRect.top;

            // Find which cell the pointer is over using collision detection
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = cellsData[r][c];
                    if (!cell) continue; // Skip if cell data is missing (should not happen in normal flow)
                    // Calculate distance from pointer to cell center
                    const distance = Math.sqrt(
                        Math.pow(pointerX - cell.centerX, 2) + Math.pow(pointerY - cell.centerY, 2)
                    );
                    // If distance is within the cell's collision radius, it's a hit
                    if (distance < cell.collisionRadius) {
                        return cell;
                    }
                }
            }
            return null; // No cell found at this position
        }

        // Clear the current selection and remove visual highlights
        function clearSelection() {
            selectedCells.forEach(cell => {
                if (cell && cell.element) cell.element.classList.remove('selected');
            });
            selectedCells = [];
            clearCanvas(); // Clear lines from canvas
        }

        // Draw lines connecting the centers of selected cells
        function drawLines() {
            clearCanvas();
            if (selectedCells.length < 2) return; // Need at least two cells to draw a line

            canvasCtx.beginPath();
            canvasCtx.strokeStyle = '#63b3ed'; // Line color (Tailwind blue-400)
            canvasCtx.lineWidth = Math.max(3, gridContainer.offsetWidth / 70); // Responsive line width
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            for (let i = 0; i < selectedCells.length; i++) {
                const cell = selectedCells[i];
                const x = cell.centerX;
                const y = cell.centerY;

                if (i === 0) {
                    canvasCtx.moveTo(x, y); // Start path at the first cell
                } else {
                    canvasCtx.lineTo(x, y); // Draw line to subsequent cells
                }
            }
            canvasCtx.stroke(); // Render the path
        }

        // Clear the line canvas
        function clearCanvas() {
            canvasCtx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
        }

        // Create particle effects for a cleared cell
        function createParticles(cell) {
            if (!cell || !gridArea) return; // Ensure cell and gridArea exist

            const startX = cell.centerX; // Center of the cell in canvas coordinates
            const startY = cell.centerY;

            for (let i = 0; i < NUM_PARTICLES_PER_CELL; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');

                // Position particle at the center of the cell initially
                // The particle's own size needs to be accounted for if its origin is top-left
                const particleSize = PARTICLE_BASE_SIZE_PX; // Use the defined base size
                particle.style.left = `${startX - particleSize / 2}px`;
                particle.style.top = `${startY - particleSize / 2}px`;

                // Randomize particle animation properties
                const angle = Math.random() * Math.PI * 2; // Random direction
                const distance = Math.random() * 60 + 30; // Random travel distance (30-90px)
                const midDistance = distance * 0.5; // Midpoint for arc-like motion

                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                const midX = Math.cos(angle) * midDistance; // Midpoint X for animation
                const midY = Math.sin(angle) * midDistance; // Midpoint Y for animation

                // Set CSS custom properties for the animation
                particle.style.setProperty('--particle-x', `${endX}px`);
                particle.style.setProperty('--particle-y', `${endY}px`);
                particle.style.setProperty('--particle-mid-x', `${midX}px`);
                particle.style.setProperty('--particle-mid-y', `${midY}px`);
                particle.style.animationDelay = `${Math.random() * 0.25}s`; // Stagger particle animations

                gridArea.appendChild(particle); // Add particle to the grid area

                // Remove particle from DOM after animation completes
                particle.addEventListener('animationend', () => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                });
            }
        }


        // Process cells that were cleared (animation, removal, gravity, refill)
        async function processClearedCells() {
            const cellsToClear = [...selectedCells]; // Copy selected cells before clearing selection
            cellsToClear.forEach(cell => createParticles(cell)); // Create particles for each cleared cell

            const tempSelectedForLine = [...selectedCells]; // Keep a copy for line clearing if needed
            selectedCells = []; // Clear the main selection immediately for responsiveness

            // Animate clearing effect
            const removalPromises = cellsToClear.map(cell => {
                if(cell && cell.element) {
                    cell.element.classList.add('clearing');
                    return new Promise(resolve => setTimeout(resolve, 600)); // Duration of clearing animation
                }
                return Promise.resolve();
            });
            await Promise.all(removalPromises);

            // Mark cells as empty in the data model
            cellsToClear.forEach(clearedCell => {
                if (clearedCell && typeof clearedCell.row === 'number' && typeof clearedCell.col === 'number' &&
                    cellsData[clearedCell.row] && cellsData[clearedCell.row][clearedCell.col]) {
                    cellsData[clearedCell.row][clearedCell.col].value = null; // Mark as empty
                    if(clearedCell.element) {
                        clearedCell.element.classList.remove('clearing'); // Clean up class
                        // Element will be reused or replaced by applyGravityAndRefill
                    }
                }
            });

            // Clear selection visual styles from the temporary list
             tempSelectedForLine.forEach(cell => {
                 if (cell && cell.element) cell.element.classList.remove('selected');
            });
            // Clear canvas lines slightly after, ensuring selection is empty
            setTimeout(() => {
                 if(selectedCells.length === 0) clearCanvas();
            }, 100);


            await applyGravityAndRefill(); // Apply gravity and refill empty spots
            generateNewMission(); // Generate a new mission
        }

        // Apply gravity to cells and refill empty spots from the top
        async function applyGravityAndRefill() {
            const animationPromises = [];

            // Apply gravity: move existing cells down
            for (let c = 0; c < GRID_SIZE; c++) { // Iterate through each column
                let emptySlotsInCol = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) { // Iterate from bottom to top of the column
                    if (!cellsData[r] || !cellsData[r][c]) continue; // Should not happen
                    const currentCellData = cellsData[r][c];

                    if (currentCellData.value === null) { // If this slot is empty
                        emptySlotsInCol++;
                    } else if (emptySlotsInCol > 0) { // If this slot has a number and there are empty slots below it
                        const newRow = r + emptySlotsInCol; // Target row for this cell to fall to
                        const cellToMove = cellsData[r][c];

                        if (!cellToMove.element) continue; // Should have an element

                        // Calculate fall distance for animation
                        const cellHeight = cellToMove.element.offsetHeight;
                        const gap = parseFloat(window.getComputedStyle(gridContainer).gap) || 8; // Get gap from CSS
                        const fallDistance = emptySlotsInCol * (cellHeight + gap);

                        // Animate the fall
                        cellToMove.element.style.transform = `translateY(${fallDistance}px)`;
                        cellToMove.element.classList.add('falling');

                        // Update data structure: move cell data to new row, mark old slot as temporarily empty
                        cellsData[newRow][c] = cellToMove;
                        cellsData[r][c] = { // Create a temporary placeholder for the old slot
                            value: null,
                            element: cellsData[r][c].element, // Keep the element reference for now
                            row: r, col: c, id: `empty-temp-${r}-${c}-${Date.now()}`,
                            centerX: cellsData[r][c].centerX, centerY: cellsData[r][c].centerY, collisionRadius: cellsData[r][c].collisionRadius
                        };
                        cellToMove.row = newRow; // Update cell's row property

                        animationPromises.push(new Promise(resolve => {
                            setTimeout(() => { // After animation duration
                                if (cellToMove.element) {
                                    cellToMove.element.style.transform = ''; // Reset transform
                                    cellToMove.element.classList.remove('falling');
                                }
                                resolve();
                            }, 500); // Duration of falling animation
                        }));
                    }
                }

                // Refill: add new cells at the top of the column for each empty slot
                for (let i = 0; i < emptySlotsInCol; i++) {
                    const newRowForNewCell = i; // New cells appear at the top (index 0, 1, etc.)
                    const newValue = Math.floor(Math.random() * (MAX_NUM - MIN_NUM + 1)) + MIN_NUM;
                    const cellToFill = cellsData[newRowForNewCell][c]; // Get the cell data for the slot to be filled

                    if (!cellToFill || !cellToFill.element) continue; // Should have an element

                    cellToFill.value = newValue; // Assign new value
                    // Element's text content will be updated in updateAllCellDisplays later
                    cellToFill.element.classList.add('new-cell'); // Add class for appearance animation

                    animationPromises.push(new Promise(resolve => {
                        setTimeout(() => { // After animation duration
                            if (cellToFill.element) {
                                cellToFill.element.classList.remove('new-cell');
                            }
                            resolve();
                        }, 500); // Duration of new cell animation
                    }));
                }
            }

            await Promise.all(animationPromises); // Wait for all fall/refill animations to complete

            // --- Rebuild grid for consistency after complex DOM manipulations ---
            // This step is crucial to ensure the DOM and cellsData are perfectly in sync,
            // especially regarding element references and their order in the grid container.

            // 1. Store the logical state (values) of the grid
            const tempGridDataValuesOnly = cellsData.map(row =>
                row.map(cell => ({ value: cell.value }))
            );

            // 2. Clear the visual grid container
            gridContainer.innerHTML = '';
            const newMasterCellsData = []; // This will become the new cellsData

            // 3. Re-create cell elements and rebuild cellsData
            for(let r=0; r<GRID_SIZE; r++) {
                const newRowData = [];
                for(let c=0; c<GRID_SIZE; c++) {
                    const valueToSet = tempGridDataValuesOnly[r][c].value;
                    const newElement = createCellElement(r,c, valueToSet); // Create a fresh DOM element
                    gridContainer.appendChild(newElement); // Add to the DOM in correct order

                    // Check if this cell was one of the "new-cell" animated ones to briefly re-apply the class for visual continuity
                    // This is a bit of a workaround for the full rebuild.
                    const originalCellData = cellsData[r][c]; // Old cellsData still has some info
                    if(originalCellData && originalCellData.element && originalCellData.element.classList.contains('new-cell')){
                        newElement.classList.add('new-cell'); // Re-apply if it was a new cell
                        setTimeout(() => newElement.classList.remove('new-cell'), 500); // And remove it after animation would have finished
                    }

                    newRowData.push({
                        value: valueToSet,
                        element: newElement, // Link to the new DOM element
                        row: r, col: c,
                        id: `cell-${r}-${c}-${Date.now()}`, // New unique ID
                        centerX: 0, centerY: 0, collisionRadius: 0 // Will be recalculated
                    });
                }
                newMasterCellsData.push(newRowData);
            }
            cellsData = newMasterCellsData; // Update the master data structure

            // 4. Recalculate positions and update display for the new grid
            resizeCanvasAndCells();
            updateAllCellDisplays();
        }

        // Update the score display on the page
        function updateScoreDisplay() {
            scoreDisplay.textContent = score;
        }

        // Show update notification
        function showUpdateNotification() {
            updateNotification.classList.add('show');
        }

        // Hide update notification
        function hideUpdateNotification() {
            updateNotification.classList.remove('show');
        }

        // Handle update button click
        function handleUpdate() {
            if (newWorker) {
                newWorker.postMessage({ action: 'skipWaiting' });
            }
        }

        // --- Event Listeners ---
        const eventAreaForInteraction = document.getElementById('grid-area'); // Use grid-area for more reliable touch boundaries

        // Mouse events
        eventAreaForInteraction.addEventListener('mousedown', handleInteractionStart);
        document.addEventListener('mousemove', handleInteractionMove); // Listen on document for mousemove outside grid
        document.addEventListener('mouseup', handleInteractionEnd);   // Listen on document for mouseup outside grid

        // Touch events
        eventAreaForInteraction.addEventListener('touchstart', handleInteractionStart, { passive: false });
        document.addEventListener('touchmove', handleInteractionMove, { passive: false }); // Listen on document for touchmove
        document.addEventListener('touchend', handleInteractionEnd);
        document.addEventListener('touchcancel', handleInteractionEnd); // Handle cancelled touches

        // Update button event
        updateButton.addEventListener('click', handleUpdate);

        // --- Initialize Game ---
        initGame();

        // --- Service Worker Registration with Update Detection ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('Service Worker registered: ', registration);

                        // Listen for updates
                        registration.addEventListener('updatefound', () => {
                            const newSW = registration.installing;
                            if (newSW) {
                                newWorker = newSW;
                                newSW.addEventListener('statechange', () => {
                                    if (newSW.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available
                                        showUpdateNotification();
                                    }
                                });
                            }
                        });

                        // Listen for service worker messages
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            if (event.data && event.data.type === 'CACHE_UPDATED') {
                                // Reload the page to get the new version
                                window.location.reload();
                            }
                        });

                        // Check if there's a waiting service worker
                        if (registration.waiting) {
                            newWorker = registration.waiting;
                            showUpdateNotification();
                        }
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed: ', error);
                    });
            });
        }
    </script>
</body>
</html>